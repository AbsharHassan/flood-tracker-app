const asyncHandler = require('express-async-handler')

const ee = require('@google/earthengine')

const FloodData = require('../models/floodDataModel')
const Geometry = require('../models/geometryModel')
// const e = require('express')

//Get object containing districts (name and geometeries) and send in the response
const getDistrictData = asyncHandler(async (req, res) => {
  const districtData = await FloodData.find()
  res.send(districtData[0])
})

//test mongodb
const getDatafromMongo = async (req, res) => {
  const entry = await FloodData.find({ data_id: '2022-01-30' })

  res.send(entry)
}

//temp function
const tempF = (req, res) => {
  var pakistan = ee
    .FeatureCollection('projects/flood-analyzer-241964/assets/gadm41_PAK_0')
    .geometry()

  var provinces = ee
    .FeatureCollection(
      'projects/flood-analyzer-241964/assets/pak_admbnda_adm1_wfp_20220909'
    )
    .geometry()

  // provinces.evaluate((geo) => {
  //   res.send(geo.coordinates)
  // })

  pakistan.evaluate((geo) => {
    res.send(geo.coordinates)
  })

  // pakistan.evaluate((geo) => {
  //   res.send(geo)
  // })
  // var isb = pakistan.filter(ee.Filter.eq('NAME_3', 'Chitral')).geometry()

  // isb.evaluate((geo) => {
  //   res.send(geo)
  // })

  // var admin0 = ee.FeatureCollection('FAO/GAUL/2015/level0')
  // var pakistan = admin0.filter(ee.Filter.eq('ADM0_NAME', 'Pakistan')).geometry()
  // pakistan.evaluate((geo) => {
  //   res.send(geo.geometries)
  // })
}

// GET FLOOD PIXELS MAP
const getMapID = (req, res) => {
  var s1 = ee.ImageCollection('COPERNICUS/S1_GRD')
  var admin2 = ee.FeatureCollection('FAO/GAUL_SIMPLIFIED_500m/2015/level2')

  const district = admin2
    .filter(ee.Filter.eq('ADM0_NAME', 'Pakistan'))
    .filter(ee.Filter.eq('ADM2_NAME', `${req.body.district}`))
    .geometry()

  // const beforeStart = '2022-03-15'
  // const beforeEnd = '2022-04-08'
  // const afterStart = `${new Date().getFullYear()}-${
  //   new Date().getMonth() - 1
  // }-${new Date().getDate()}`
  // const afterEnd = `${new Date().getFullYear()}-${
  //   new Date().getMonth() + 1
  // }-${new Date().getDate()}`

  var beforeStart = '2022-03-15'
  var beforeEnd = '2022-04-08'
  var afterStart = '2022-07-01'
  var afterEnd = '2022-08-30'

  const floodPixels = getFloodPixels(
    district,
    beforeStart,
    beforeEnd,
    afterStart,
    afterEnd,
    s1
  )

  floodPixels.getMap(
    { min: 0, max: 1, palette: 'blue', opacity: 0.3 },
    ({ mapid }) => {
      res.send(mapid)
    }
  )
}

const getDistrictPolygons = (req, res) => {
  const admin2 = ee.FeatureCollection('FAO/GAUL_SIMPLIFIED_500m/2015/level2')

  const districts = admin2.filter(ee.Filter.eq('ADM0_NAME', 'Pakistan'))

  const getGeometeries = (district) => {
    const centerPoint = ee
      .Feature(district)
      .centroid({ maxError: 1 })
      .geometry()
      .coordinates()

    return {
      district: ee.Feature(district).get('ADM2_NAME'),
      geometry: ee.Feature(district).geometry(),
      center: { coordinates: centerPoint },
    }
  }

  districts.evaluate((featureCollection) => {
    let temporaryHoldingArray = []
    let nullWarningCounter = 0
    let completenessCounter = 0
    for (var index = 0; index < featureCollection.features.length; index++) {
      let districtsArray = districts.toList(1, parseInt(index))

      let districtsGeometricalData = districtsArray.map(getGeometeries)

      districtsGeometricalData.evaluate(async (dataObj) => {
        completenessCounter++
        console.log(completenessCounter)

        if (dataObj[0]) {
          temporaryHoldingArray.push(dataObj[0])
        } else {
          temporaryHoldingArray.push(null)
          nullWarningCounter++
        }

        if (completenessCounter === featureCollection.features.length) {
          await Geometry.create({
            districts: temporaryHoldingArray,
          })
          res.json({
            message: `Request fulfilled with ${nullWarningCounter} null responses`,
            nullCounts: nullWarningCounter,
          })
        }
      })
    }
  })
}

const landClassificationDataGenerator = async (req, res) => {
  var s1 = ee.ImageCollection('COPERNICUS/S1_GRD')
  var s2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
  var ESAworldcover = ee.ImageCollection('ESA/WorldCover/v100')
  var admin2 = ee.FeatureCollection('FAO/GAUL_SIMPLIFIED_500m/2015/level2')
  var trainingTable = ee.FeatureCollection(
    'projects/flood-analyzer-241964/assets/TrainingPointsV1'
  )
  var roads = ee.FeatureCollection(
    'projects/flood-analyzer-241964/assets/gis_osm_roads_free_1'
  )

  var districts = admin2.filter(ee.Filter.eq('ADM0_NAME', 'Pakistan'))

  // var beforeStart = '2022-03-15'
  // var beforeEnd = '2022-04-08'
  // var afterStart = `${new Date().getFullYear()}-${
  //   new Date().getMonth() - 2
  // }-${new Date().getDate()}`
  // var afterEnd = `${new Date().getFullYear()}-${
  //   new Date().getMonth() + 1
  // }-${new Date().getDate()}`

  var beforeStartTraining = '2022-01-01'
  var beforeEndTraining = '2022-04-08'

  var beforeStart = '2022-03-01'
  var beforeEnd = '2022-05-30'
  var afterStart = '2022-04-01'
  var afterEnd = '2022-04-30'

  // console.log(req.body)

  // if (req.body.afterStartDate && req.body.afterEndDate) {
  //   // res.json({
  //   //   start: new Date(req.body.afterStartDate),
  //   //   end: req.body.afterEndDate,
  //   // })
  //   res.json({
  //     date: new Date(req.body.afterStartDate).getDay(),
  //   })
  //   console.log(new Date(req.body.afterStartDate).getDate())
  // } else {
  //   res.json({
  //     error: 'cannot read dates.',
  //   })
  // }
  // var afterStart = req.body.afterStartDate
  // var afterEnd = req.body.afterEndDate

  await FloodData.create({
    data_id: afterEnd,
    districts: [],
  })

  var beforeFloodSat2 = s2
    .filterDate(beforeStartTraining, beforeEndTraining)
    .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5))
    .mean()

  var trainingPoints = trainingTable
  var trainingLabel = 'class'
  var trainingBands = [
    'B2',
    'B3',
    'B4',
    'B5',
    'B6',
    'B7',
    'B8',
    'B11',
    'B12',
    'WVP',
  ]
  var trainingInput = beforeFloodSat2.select(trainingBands)
  var trainImage = trainingInput.sampleRegions({
    collection: trainingPoints,
    properties: [trainingLabel],
    scale: 35,
  })
  var trainingData = trainImage.randomColumn()
  var trainingSet = trainingData.filter(ee.Filter.lessThan('random', 0.8))
  var testingSet = trainingData.filter(
    ee.Filter.greaterThanOrEquals('random', 0.8)
  )

  var classifier = ee.Classifier.smileCart().train(
    trainingSet,
    trainingLabel,
    trainingBands
  )

  var confusionMatrix = ee.ConfusionMatrix(
    testingSet.classify(classifier).errorMatrix({
      actual: 'class',
      predicted: 'classification',
    })
  )

  var accuracyMl = ee.ConfusionMatrix(confusionMatrix).accuracy()

  //MAP OVER DISTRICTS TO YEILD STATS FOR EACH
  const districtLandcoverGeneralFunction = function (district) {
    const classifiedLayer = beforeFloodSat2.classify(classifier)

    const urbanPixelsESA = ESAworldcover.first().updateMask(
      ESAworldcover.first().eq(50)
    )

    let urbanImageESA = urbanPixelsESA
      .select('Map')
      .divide(urbanPixelsESA.select('Map'))
      .rename('class')

    urbanImageESA = urbanImageESA.cast({
      class: 'uint8',
    })

    const completeClassifiedBefore = urbanImageESA.unmask(classifiedLayer)

    let floodPixels = getFloodPixels(
      ee.Feature(district).geometry(),
      beforeStart,
      beforeEnd,
      afterStart,
      afterEnd,
      s1
    )

    floodPixels = floodPixels
      .select('FloodWater')
      .divide(floodPixels.select('FloodWater'))
      .multiply(6)
      .rename('class')
    floodPixels = floodPixels.cast({
      class: 'uint8',
    })

    const completeClassifiedAfter = floodPixels.unmask(completeClassifiedBefore)

    //Statistical Analaysis
    const beforeFloodClassObj = ee.Dictionary({
      1: 'urban',
      2: 'normalWater',
      3: 'farmland',
      4: 'snowClouds',
      5: 'barren',
    })

    const districtArea = ee.Feature(district).area()

    const beforeFloodAreaImage = ee.Image.pixelArea().addBands(
      completeClassifiedBefore
    )

    let classAreasBefore = beforeFloodAreaImage
      .reduceRegion({
        reducer: ee.Reducer.sum().group({
          groupField: 1,
          groupName: 'class',
        }),
        geometry: ee.Feature(district).geometry(),
        scale: 30,
        maxPixels: 1e20,
        tileScale: 4,
      })
      .get('groups')

    classAreasBefore = ee.List(classAreasBefore)

    const classAreasListBefore = classAreasBefore
      .map(function (entry) {
        const areaObj = ee.Dictionary(entry)
        const classNumber = ee.Number(areaObj.get('class')).format()
        const areaPercentage = ee
          .Number(areaObj.get('sum'))
          .divide(districtArea)
          .multiply(100)
        return ee.List([beforeFloodClassObj.get(classNumber), areaPercentage])
      })
      .flatten()

    const beforeFloodAreaResult = ee.Dictionary(classAreasListBefore)

    const afterFloodClassObj = ee.Dictionary({
      1: 'urban',
      2: 'normaWater',
      3: 'farmland',
      4: 'snowClouds',
      5: 'barren',
      6: 'floodWater',
    })

    const afterFloodAreaImage = ee.Image.pixelArea().addBands(
      completeClassifiedAfter.clip(ee.Feature(district).geometry())
    )

    let classAreasAfter = afterFloodAreaImage
      .reduceRegion({
        reducer: ee.Reducer.sum().group({
          groupField: 1,
          groupName: 'class',
        }),
        geometry: ee.Feature(district).geometry(),
        scale: 30,
        maxPixels: 1e20,
        tileScale: 4,
      })
      .get('groups')

    classAreasAfter = ee.List(classAreasAfter)

    const classAreasListAfter = classAreasAfter
      .map(function (entry) {
        const areaObj = ee.Dictionary(entry)
        const classNumber = ee.Number(areaObj.get('class')).format()
        const areaPercentage = ee
          .Number(areaObj.get('sum'))
          .divide(districtArea)
          .multiply(100)
        return ee.List([afterFloodClassObj.get(classNumber), areaPercentage])
      })
      .flatten()

    const afterFloodAreaResult = ee.Dictionary(classAreasListAfter)

    let floodedRoads = floodPixels.clip(roads)

    let var1 = ee.Algorithms.If(
      ee.String(ee.Feature(district).get('ADM1_NAME')).equals('Balochistan'),
      ee.Number(1),
      ee.Number(0)
    )

    let var2 = ee.Algorithms.If(
      ee
        .String(ee.Feature(district).get('ADM2_NAME'))
        .equals('Nasirabad District'),
      ee.Number(0),
      ee.Number(1)
    )

    let var3 = ee.Number(var1).and(ee.Number(var2))

    let customConnectedPixelCount = ee.Algorithms.If(
      var3,
      ee.Number(15),
      ee.Number(100)
    )
    let connectedPixelsThreshold = ee.Algorithms.If(
      var3,
      ee.Number(8),
      ee.Number(50)
    )
    const connections = floodedRoads.connectedPixelCount(
      ee.Number(customConnectedPixelCount)
    )
    floodedRoads = floodedRoads.updateMask(
      connections.gt(ee.Number(connectedPixelsThreshold))
    )

    let scale = ee.Algorithms.If(
      ee.String(ee.Feature(district).get('ADM1_NAME')).equals('Balochistan'),
      ee.Number(100),
      ee.Number(80)
    )

    const floodedRoadVectors = floodedRoads.reduceToVectors({
      geometry: ee.Feature(district).geometry(),
      scale: 120,
      eightConnected: true,
      maxPixels: 1e10,
      tileScale: 1,
    })

    const floodedRoadArray = floodedRoadVectors.toList(1e5)

    const getCenters = function (feature) {
      return ee
        .Feature(feature)
        .centroid({ maxError: 1 })
        .geometry()
        .coordinates()
    }

    const floodedRoadsCentroids = floodedRoadArray.map(getCenters)

    var getLatLong = function (img) {
      // Get the projection
      var proj = img.select([0]).projection()
      // get coordinates image
      var latlon = ee.Image.pixelLonLat() //.reproject(proj)
      var img1 = img.addBands(latlon.select('longitude', 'latitude'))

      return img1
    }

    var floodedPixelsCoords = getLatLong(floodPixels)

    var meanFloodPixel = floodedPixelsCoords.select([1, 2]).reduceRegion({
      reducer: ee.Reducer.mean(),
      geometry: ee.Feature(district).geometry(),
      scale: 10,
      maxPixels: 1e20,
    })

    var centerPointGeometry = ee.Geometry.Point([
      meanFloodPixel.get('longitude'),
      meanFloodPixel.get('latitude'),
    ])

    return {
      district: ee.Feature(district).get('ADM2_NAME'),
      // center: centerPointGeometry,
      // geometry: ee.Feature(district).geometry(),
      results: {
        total: districtArea,
        before: beforeFloodAreaResult,
        after: afterFloodAreaResult,
        roads: floodedRoadsCentroids,
      },
    }
  }

  var exitCounter = 1

  // let osme = await District.findOne()
  // console.log(osme)

  // districts.evaluate(async (districtsCollection) => {
  //   // MAYBE SEND A CALL TO THE DB TO CHECK IF LENTH IS EQUAL TO districtsCollection.features.length THEN SEND res.send
  //   // res.send(districtsCollection.features.length.toString())

  //   var warningCounter = 1
  //   var ourSpecialHelper = 0
  //   var storageArray = []

  //   for (var index = 0; index < districtsCollection.features.length; index++) {
  //     districtsArray = districts.toList(1, parseInt(index))

  //     districtsFloodData = districtsArray.map(districtLandcoverGeneralFunction)

  //     districtsFloodData.evaluate(async (ans) => {
  //       ourSpecialHelper = ourSpecialHelper + 1

  //       if (ans) {
  //         storageArray.push(ans[0])
  //       } else {
  //         storageArray.push('no.')
  //         warningCounter = warningCounter + 1
  //       }

  //       // res.send(ans)

  //       // let lengthChecker = await District.findOneAndUpdate({
  //       //   $push: {
  //       //     districts: ans[0] || null,
  //       //   },
  //       // })
  //       console.log(ourSpecialHelper)
  //       if (ourSpecialHelper == 119) {
  //         let lengthChecker = await District.findOneAndUpdate({
  //           $set: {
  //             districts: storageArray,
  //           },
  //         })
  //         if (!warningCounter) {
  //           res.json({
  //             message: 'request completed',
  //             undefinedResults: warningCounter,
  //           })
  //         } else {
  //         }
  //       }

  //       //HELPS UNDERSTAND THE STUFF
  //       // districtsFloodData.evaluate(async (ans) => {
  //       //   // res.send(ans)
  //       //   // console.log(ans)

  //       //   ourSpecialHelper = ourSpecialHelper + 1

  //       //   if (ans) {
  //       //     storageArray.push(
  //       //       'YASSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS'
  //       //     )
  //       //   } else {
  //       //     storageArray.push('no.')
  //       //   }

  //       //   // res.send(ans)

  //       //   // let lengthChecker = await District.findOneAndUpdate({
  //       //   //   $push: {
  //       //   //     districts: ans[0] || null,
  //       //   //   },
  //       //   // })
  //       //   // console.log(lengthChecker.districts.length)
  //       //   console.log(ourSpecialHelper)
  //       //   if (ourSpecialHelper == 119) {
  //       //     res.send(storageArray)
  //       //   }

  //       //   // console.log(storageArray)
  //       //   // let osme = await District.findOne()
  //       //   // console.log(osme.districts)
  //       // })

  //       // console.log(storageArray)
  //       // let osme = await District.findOne()
  //       // console.log(osme.districts)
  //     })
  //   }

  //   warningCounter = 0

  //   for (var index = 0; index < districtsCollection.features.length; index++) {
  //     districtsArray = districts.toList(1, parseInt(index))

  //     districtsFloodData = districtsArray.map(districtLandcoverGeneralFunction)

  //     districtsFloodData.evaluate(async (ans) => {
  //       ourSpecialHelper = ourSpecialHelper + 1

  //       if (ans) {
  //         storageArray.push(ans[0])
  //       } else {
  //         storageArray.push('no.')
  //         warningCounter = warningCounter + 1
  //       }

  //       // res.send(ans)

  //       // let lengthChecker = await District.findOneAndUpdate({
  //       //   $push: {
  //       //     districts: ans[0] || null,
  //       //   },
  //       // })
  //       console.log(ourSpecialHelper)
  //       if (ourSpecialHelper == 119) {
  //         let lengthChecker = await District.findOneAndUpdate({
  //           $set: {
  //             districts: storageArray,
  //           },
  //         })
  //         if (warningCounter == 0) {
  //           res.json({
  //             message: 'request completed',
  //             undefinedResults: warningCounter,
  //           })
  //         } else {
  //         }
  //       }

  //       //HELPS UNDERSTAND THE STUFF
  //       // districtsFloodData.evaluate(async (ans) => {
  //       //   // res.send(ans)
  //       //   // console.log(ans)

  //       //   ourSpecialHelper = ourSpecialHelper + 1

  //       //   if (ans) {
  //       //     storageArray.push(
  //       //       'YASSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS'
  //       //     )
  //       //   } else {
  //       //     storageArray.push('no.')
  //       //   }

  //       //   // res.send(ans)

  //       //   // let lengthChecker = await District.findOneAndUpdate({
  //       //   //   $push: {
  //       //   //     districts: ans[0] || null,
  //       //   //   },
  //       //   // })
  //       //   // console.log(lengthChecker.districts.length)
  //       //   console.log(ourSpecialHelper)
  //       //   if (ourSpecialHelper == 119) {
  //       //     res.send(storageArray)
  //       //   }

  //       //   // console.log(storageArray)
  //       //   // let osme = await District.findOne()
  //       //   // console.log(osme.districts)
  //       // })

  //       // console.log(storageArray)
  //       // let osme = await District.findOne()
  //       // console.log(osme.districts)
  //     })
  //   }

  //   // for (var index = 0; index < districtsCollection.features.length; index++) {
  //   //   districtsArray = districts.toList(1, parseInt(index))

  //   //   districtsFloodData = districtsArray.map(districtLandcoverGeneralFunction)

  //   //   // const databaseArray = await District.findOne()
  //   //   // console.log(databaseArray.districts.length)

  //   //   await districtsFloodData.evaluate(async (resultArray) => {
  //   //     console.log(exitCounter)
  //   //     if (!(exitCounter > districtsCollection.features.length - 1)) {
  //   //       if (resultArray) {
  //   //         await District.findOneAndUpdate(
  //   //           {
  //   //             data_id: afterEnd,
  //   //           },
  //   //           {
  //   //             $push: {
  //   //               districts: resultArray[0] || null,
  //   //             },
  //   //           }
  //   //         )
  //   //       } else {
  //   //         await District.findOneAndUpdate(
  //   //           {
  //   //             data_id: afterEnd,
  //   //           },
  //   //           {
  //   //             $push: {
  //   //               districts: null,
  //   //             },
  //   //           }
  //   //         )
  //   //       }
  //   //       exitCounter++
  //   //     } else {
  //   //       // res.send('Completed')
  //   //       if (resultArray) {
  //   //         await District.findOneAndUpdate(
  //   //           {
  //   //             data_id: afterEnd,
  //   //           },
  //   //           {
  //   //             $push: {
  //   //               districts: resultArray[0] || null,
  //   //             },
  //   //           }
  //   //         )
  //   //       } else {
  //   //         await District.findOneAndUpdate(
  //   //           {
  //   //             data_id: afterEnd,
  //   //           },
  //   //           {
  //   //             $push: {
  //   //               districts: null,
  //   //             },
  //   //           }
  //   //         )
  //   //       }
  //   //       // res.send('Completed')
  //   //     }
  //   //   })
  //   // }
  // })

  districts.evaluate(async (districtsCollection) => {
    let nullWarningCounter = 0
    let completenessCounter = 0
    let temporaryHoldingArray = []

    for (var index = 0; index < districtsCollection.features.length; index++) {
      districtsArray = districts.toList(1, parseInt(index))

      districtsFloodData = districtsArray.map(districtLandcoverGeneralFunction)

      districtsFloodData.evaluate(async (resultsObj) => {
        completenessCounter++
        console.log(completenessCounter)

        if (resultsObj) {
          temporaryHoldingArray.push(resultsObj[0])
        } else {
          temporaryHoldingArray.push(null)
          nullWarningCounter++
        }

        console.log(completenessCounter)
        if (completenessCounter == districtsCollection.features.length) {
          await FloodData.create(
            {
              data_id: afterEnd,
            },
            {
              districts: temporaryHoldingArray,
            }
          )
          res.json({
            message: `Request fulfilled with ${nullWarningCounter} null responses`,
            nullCounts: nullWarningCounter,
          })
        }
      })
    }
  })
}

// if (completenessCounter == districtsCollection.features.length) {
//   await FloodData.findOneAndUpdate(
//     {
//       data_id: afterEnd,
//     },
//     {
//       $set: {
//         districts: temporaryHoldingArray,
//       },
//     }
//   )
//   await FloodData.f
//   res.json({
//     message: 'request completed',
//     undefinedResults: nullWarningCounter,
//   })
// }

//CLASSIFY LANDCOVER AND PRODUCE STATISTICAL RESULTS
// const landClassificationDataGenerator = async (req, res) => {
//   var s1 = ee.ImageCollection('COPERNICUS/S1_GRD')
//   var s2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
//   var ESAworldcover = ee.ImageCollection('ESA/WorldCover/v100')
//   var admin2 = ee.FeatureCollection('FAO/GAUL_SIMPLIFIED_500m/2015/level2')
//   var trainingTable = ee.FeatureCollection(
//     'projects/flood-analyzer-241964/assets/TrainingPointsV1'
//   )
//   var roads = ee.FeatureCollection(
//     'projects/flood-analyzer-241964/assets/gis_osm_roads_free_1'
//   )

//   var districts = admin2.filter(ee.Filter.eq('ADM0_NAME', 'Pakistan'))

//   // var beforeStart = '2022-03-15'
//   // var beforeEnd = '2022-04-08'
//   // var afterStart = `${new Date().getFullYear()}-${
//   //   new Date().getMonth() - 2
//   // }-${new Date().getDate()}`
//   // var afterEnd = `${new Date().getFullYear()}-${
//   //   new Date().getMonth() + 1
//   // }-${new Date().getDate()}`

//   var beforeStart = '2022-03-15'
//   var beforeEnd = '2022-04-08'
//   var afterStart = '2022-06-30'
//   var afterEnd = '2022-08-30'

//   await District.create({
//     data_id: afterEnd,
//     districts: [],
//   })

//   var beforeFloodSat2 = s2
//     .filterDate(beforeStart, beforeEnd)
//     .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5))
//     .mean()

//   var trainingPoints = trainingTable
//   var trainingLabel = 'class'
//   var trainingBands = [
//     'B2',
//     'B3',
//     'B4',
//     'B5',
//     'B6',
//     'B7',
//     'B8',
//     'B11',
//     'B12',
//     'WVP',
//   ]
//   var trainingInput = beforeFloodSat2.select(trainingBands)
//   var trainImage = trainingInput.sampleRegions({
//     collection: trainingPoints,
//     properties: [trainingLabel],
//     scale: 35,
//   })
//   var trainingData = trainImage.randomColumn()
//   var trainingSet = trainingData.filter(ee.Filter.lessThan('random', 0.8))
//   var testingSet = trainingData.filter(
//     ee.Filter.greaterThanOrEquals('random', 0.8)
//   )

//   var classifier = ee.Classifier.smileCart().train(
//     trainingSet,
//     trainingLabel,
//     trainingBands
//   )

//   var confusionMatrix = ee.ConfusionMatrix(
//     testingSet.classify(classifier).errorMatrix({
//       actual: 'class',
//       predicted: 'classification',
//     })
//   )

//   var accuracy = ee.ConfusionMatrix(confusionMatrix).accuracy()

//   // console.log(accuracy)

//   //MAP OVER DISTRICTS TO YEILD STATS FOR EACH
//   const districtLandcoverGeneralFunction = function (district) {
//     const classifiedLayer = beforeFloodSat2.classify(classifier)

//     const urbanPixelsESA = ESAworldcover.first().updateMask(
//       ESAworldcover.first().eq(50)
//     )

//     let urbanImageESA = urbanPixelsESA
//       .select('Map')
//       .divide(urbanPixelsESA.select('Map'))
//       .rename('class')

//     urbanImageESA = urbanImageESA.cast({
//       class: 'uint8',
//     })

//     const completeClassifiedBefore = urbanImageESA.unmask(classifiedLayer)

//     let floodPixels = getFloodPixels(
//       ee.Feature(district).geometry(),
//       beforeStart,
//       beforeEnd,
//       afterStart,
//       afterEnd,
//       s1
//     )

//     floodPixels = floodPixels
//       .select('FloodWater')
//       .divide(floodPixels.select('FloodWater'))
//       .multiply(6)
//       .rename('class')
//     floodPixels = floodPixels.cast({
//       class: 'uint8',
//     })

//     const completeClassifiedAfter = floodPixels.unmask(completeClassifiedBefore)

//     //Statistical Analaysis
//     const beforeFloodClassObj = ee.Dictionary({
//       1: 'urban',
//       2: 'normalWater',
//       3: 'farmland',
//       4: 'snowClouds',
//       5: 'barren',
//     })

//     const districtArea = ee.Feature(district).area()

//     const beforeFloodAreaImage = ee.Image.pixelArea().addBands(
//       completeClassifiedBefore
//     )

//     let classAreasBefore = beforeFloodAreaImage
//       .reduceRegion({
//         reducer: ee.Reducer.sum().group({
//           groupField: 1,
//           groupName: 'class',
//         }),
//         geometry: ee.Feature(district).geometry(),
//         scale: 30,
//         maxPixels: 1e20,
//         tileScale: 4,
//       })
//       .get('groups')

//     classAreasBefore = ee.List(classAreasBefore)

//     const classAreasListBefore = classAreasBefore
//       .map(function (entry) {
//         const areaObj = ee.Dictionary(entry)
//         const classNumber = ee.Number(areaObj.get('class')).format()
//         const areaPercentage = ee
//           .Number(areaObj.get('sum'))
//           .divide(districtArea)
//           .multiply(100)
//         return ee.List([beforeFloodClassObj.get(classNumber), areaPercentage])
//       })
//       .flatten()

//     const beforeFloodAreaResult = ee.Dictionary(classAreasListBefore)

//     const afterFloodClassObj = ee.Dictionary({
//       1: 'urban',
//       2: 'normaWater',
//       3: 'farmland',
//       4: 'snowClouds',
//       5: 'barren',
//       6: 'floodWater',
//     })

//     const afterFloodAreaImage = ee.Image.pixelArea().addBands(
//       completeClassifiedAfter.clip(ee.Feature(district).geometry())
//     )

//     let classAreasAfter = afterFloodAreaImage
//       .reduceRegion({
//         reducer: ee.Reducer.sum().group({
//           groupField: 1,
//           groupName: 'class',
//         }),
//         geometry: ee.Feature(district).geometry(),
//         scale: 30,
//         maxPixels: 1e20,
//         tileScale: 4,
//       })
//       .get('groups')

//     classAreasAfter = ee.List(classAreasAfter)

//     const classAreasListAfter = classAreasAfter
//       .map(function (entry) {
//         const areaObj = ee.Dictionary(entry)
//         const classNumber = ee.Number(areaObj.get('class')).format()
//         const areaPercentage = ee
//           .Number(areaObj.get('sum'))
//           .divide(districtArea)
//           .multiply(100)
//         return ee.List([afterFloodClassObj.get(classNumber), areaPercentage])
//       })
//       .flatten()

//     const afterFloodAreaResult = ee.Dictionary(classAreasListAfter)

//     let floodedRoads = floodPixels.clip(roads)

//     let var1 = ee.Algorithms.If(
//       ee.String(ee.Feature(district).get('ADM1_NAME')).equals('Balochistan'),
//       ee.Number(1),
//       ee.Number(0)
//     )

//     let var2 = ee.Algorithms.If(
//       ee
//         .String(ee.Feature(district).get('ADM2_NAME'))
//         .equals('Nasirabad District'),
//       ee.Number(0),
//       ee.Number(1)
//     )

//     let var3 = ee.Number(var1).and(ee.Number(var2))

//     let customConnectedPixelCount = ee.Algorithms.If(
//       var3,
//       ee.Number(15),
//       ee.Number(100)
//     )
//     let connectedPixelsThreshold = ee.Algorithms.If(
//       var3,
//       ee.Number(8),
//       ee.Number(50)
//     )
//     const connections = floodedRoads.connectedPixelCount(
//       ee.Number(customConnectedPixelCount)
//     )
//     floodedRoads = floodedRoads.updateMask(
//       connections.gt(ee.Number(connectedPixelsThreshold))
//     )

//     let scale = ee.Algorithms.If(
//       ee.String(ee.Feature(district).get('ADM1_NAME')).equals('Balochistan'),
//       ee.Number(100),
//       ee.Number(80)
//     )

//     const floodedRoadVectors = floodedRoads.reduceToVectors({
//       geometry: ee.Feature(district).geometry(),
//       scale: 120,
//       eightConnected: true,
//       maxPixels: 1e10,
//       tileScale: 1,
//     })

//     const floodedRoadArray = floodedRoadVectors.toList(1e5)

//     const getCenters = function (feature) {
//       return ee
//         .Feature(feature)
//         .centroid({ maxError: 1 })
//         .geometry()
//         .coordinates()
//     }

//     const floodedRoadsCentroids = floodedRoadArray.map(getCenters)

//     var getLatLong = function (img) {
//       // Get the projection
//       var proj = img.select([0]).projection()
//       // get coordinates image
//       var latlon = ee.Image.pixelLonLat() //.reproject(proj)
//       var img1 = img.addBands(latlon.select('longitude', 'latitude'))

//       return img1
//     }

//     var floodedPixelsCoords = getLatLong(floodPixels)

//     var meanFloodPixel = floodedPixelsCoords.select([1, 2]).reduceRegion({
//       reducer: ee.Reducer.mean(),
//       geometry: ee.Feature(district).geometry(),
//       scale: 10,
//       maxPixels: 1e20,
//     })

//     var centerPointGeometry = ee.Geometry.Point([
//       meanFloodPixel.get('longitude'),
//       meanFloodPixel.get('latitude'),
//     ])

//     return {
//       district: ee.Feature(district).get('ADM2_NAME'),
//       center: centerPointGeometry,
//       geometry: ee.Feature(district).geometry(),
//       results: {
//         total: districtArea,
//         before: beforeFloodAreaResult,
//         after: afterFloodAreaResult,
//         roads: floodedRoadsCentroids,
//       },
//     }
//   }

//   var exitCounter = 1

//   districts.evaluate(async (districtsCollection) => {
//     // MAYBE SEND A CALL TO THE DB TO CHECK IF LENTH IS EQUAL TO districtsCollection.features.length THEN SEND res.send
//     // res.send(districtsCollection.features.length.toString())
//     for (var index = 0; index < districtsCollection.features.length; index++) {
//       districtsArray = districts.toList(1, parseInt(index))

//       districtsFloodData = districtsArray.map(districtLandcoverGeneralFunction)

//       // const databaseArray = await District.findOne()
//       // console.log(databaseArray.districts.length)

//       await districtsFloodData.evaluate(async (resultArray) => {
//         console.log(exitCounter)
//         if (!(exitCounter > districtsCollection.features.length - 1)) {
//           if (resultArray) {
//             await District.findOneAndUpdate(
//               {
//                 data_id: afterEnd,
//               },
//               {
//                 $push: {
//                   districts: resultArray[0] || null,
//                 },
//               }
//             )
//           } else {
//             await District.findOneAndUpdate(
//               {
//                 data_id: afterEnd,
//               },
//               {
//                 $push: {
//                   districts: null,
//                 },
//               }
//             )
//           }
//           exitCounter++
//         } else {
//           // res.send('Completed')
//           if (resultArray) {
//             await District.findOneAndUpdate(
//               {
//                 data_id: afterEnd,
//               },
//               {
//                 $push: {
//                   districts: resultArray[0] || null,
//                 },
//               }
//             )
//           } else {
//             await District.findOneAndUpdate(
//               {
//                 data_id: afterEnd,
//               },
//               {
//                 $push: {
//                   districts: null,
//                 },
//               }
//             )
//           }
//           // res.send('Completed')
//         }
//       })
//     }
//   })
// }

// const landClassificationDataGenerator = async (req, res) => {
//   var s1 = ee.ImageCollection('COPERNICUS/S1_GRD')
//   var s2 = ee.ImageCollection('COPERNICUS/S2_SR_HARMONIZED')
//   var ESAworldcover = ee.ImageCollection('ESA/WorldCover/v100')
//   var admin2 = ee.FeatureCollection('FAO/GAUL_SIMPLIFIED_500m/2015/level2')
//   var trainingTable = ee.FeatureCollection(
//     'projects/flood-analyzer-241964/assets/TrainingPointsV1'
//   )
//   var roads = ee.FeatureCollection(
//     'projects/flood-analyzer-241964/assets/gis_osm_roads_free_1'
//   )

//   var districts = admin2.filter(ee.Filter.eq('ADM0_NAME', 'Pakistan'))

//   // var beforeStart = '2022-03-15'
//   // var beforeEnd = '2022-04-08'
//   // var afterStart = `${new Date().getFullYear()}-${
//   //   new Date().getMonth() - 2
//   // }-${new Date().getDate()}`
//   // var afterEnd = `${new Date().getFullYear()}-${
//   //   new Date().getMonth() + 1
//   // }-${new Date().getDate()}`

//   var beforeStart = '2022-03-15'
//   var beforeEnd = '2022-04-08'
//   var afterStart = '2022-06-30'
//   var afterEnd = '2022-08-30'

//   await District.create({
//     data_id: afterEnd,
//     districts: [],
//   })

//   var beforeFloodSat2 = s2
//     .filterDate(beforeStart, beforeEnd)
//     .filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5))
//     .mean()

//   var trainingPoints = trainingTable
//   var trainingLabel = 'class'
//   var trainingBands = [
//     'B2',
//     'B3',
//     'B4',
//     'B5',
//     'B6',
//     'B7',
//     'B8',
//     'B11',
//     'B12',
//     'WVP',
//   ]
//   var trainingInput = beforeFloodSat2.select(trainingBands)
//   var trainImage = trainingInput.sampleRegions({
//     collection: trainingPoints,
//     properties: [trainingLabel],
//     scale: 35,
//   })
//   var trainingData = trainImage.randomColumn()
//   var trainingSet = trainingData.filter(ee.Filter.lessThan('random', 0.8))
//   var testingSet = trainingData.filter(
//     ee.Filter.greaterThanOrEquals('random', 0.8)
//   )

//   var classifier = ee.Classifier.smileCart().train(
//     trainingSet,
//     trainingLabel,
//     trainingBands
//   )

//   var confusionMatrix = ee.ConfusionMatrix(
//     testingSet.classify(classifier).errorMatrix({
//       actual: 'class',
//       predicted: 'classification',
//     })
//   )

//   var accuracy = ee.ConfusionMatrix(confusionMatrix).accuracy()

//   // console.log(accuracy)

//   //MAP OVER DISTRICTS TO YEILD STATS FOR EACH
//   const districtLandcoverGeneralFunction = function (district) {
//     return new Promise((resolve) => {
//       const classifiedLayer = beforeFloodSat2.classify(classifier)

//       const urbanPixelsESA = ESAworldcover.first().updateMask(
//         ESAworldcover.first().eq(50)
//       )

//       let urbanImageESA = urbanPixelsESA
//         .select('Map')
//         .divide(urbanPixelsESA.select('Map'))
//         .rename('class')

//       urbanImageESA = urbanImageESA.cast({
//         class: 'uint8',
//       })

//       const completeClassifiedBefore = urbanImageESA.unmask(classifiedLayer)

//       let floodPixels = getFloodPixels(
//         ee.Feature(district).geometry(),
//         beforeStart,
//         beforeEnd,
//         afterStart,
//         afterEnd,
//         s1
//       )

//       floodPixels = floodPixels
//         .select('FloodWater')
//         .divide(floodPixels.select('FloodWater'))
//         .multiply(6)
//         .rename('class')
//       floodPixels = floodPixels.cast({
//         class: 'uint8',
//       })

//       const completeClassifiedAfter = floodPixels.unmask(
//         completeClassifiedBefore
//       )

//       //Statistical Analaysis
//       const beforeFloodClassObj = ee.Dictionary({
//         1: 'urban',
//         2: 'normalWater',
//         3: 'farmland',
//         4: 'snowClouds',
//         5: 'barren',
//       })

//       const districtArea = ee.Feature(district).area()

//       const beforeFloodAreaImage = ee.Image.pixelArea().addBands(
//         completeClassifiedBefore
//       )

//       let classAreasBefore = beforeFloodAreaImage
//         .reduceRegion({
//           reducer: ee.Reducer.sum().group({
//             groupField: 1,
//             groupName: 'class',
//           }),
//           geometry: ee.Feature(district).geometry(),
//           scale: 30,
//           maxPixels: 1e20,
//           tileScale: 4,
//         })
//         .get('groups')

//       classAreasBefore = ee.List(classAreasBefore)

//       const classAreasListBefore = classAreasBefore
//         .map(function (entry) {
//           const areaObj = ee.Dictionary(entry)
//           const classNumber = ee.Number(areaObj.get('class')).format()
//           const areaPercentage = ee
//             .Number(areaObj.get('sum'))
//             .divide(districtArea)
//             .multiply(100)
//           return ee.List([beforeFloodClassObj.get(classNumber), areaPercentage])
//         })
//         .flatten()

//       const beforeFloodAreaResult = ee.Dictionary(classAreasListBefore)

//       const afterFloodClassObj = ee.Dictionary({
//         1: 'urban',
//         2: 'normaWater',
//         3: 'farmland',
//         4: 'snowClouds',
//         5: 'barren',
//         6: 'floodWater',
//       })

//       const afterFloodAreaImage = ee.Image.pixelArea().addBands(
//         completeClassifiedAfter.clip(ee.Feature(district).geometry())
//       )

//       let classAreasAfter = afterFloodAreaImage
//         .reduceRegion({
//           reducer: ee.Reducer.sum().group({
//             groupField: 1,
//             groupName: 'class',
//           }),
//           geometry: ee.Feature(district).geometry(),
//           scale: 30,
//           maxPixels: 1e20,
//           tileScale: 4,
//         })
//         .get('groups')

//       classAreasAfter = ee.List(classAreasAfter)

//       const classAreasListAfter = classAreasAfter
//         .map(function (entry) {
//           const areaObj = ee.Dictionary(entry)
//           const classNumber = ee.Number(areaObj.get('class')).format()
//           const areaPercentage = ee
//             .Number(areaObj.get('sum'))
//             .divide(districtArea)
//             .multiply(100)
//           return ee.List([afterFloodClassObj.get(classNumber), areaPercentage])
//         })
//         .flatten()

//       const afterFloodAreaResult = ee.Dictionary(classAreasListAfter)

//       let floodedRoads = floodPixels.clip(roads)

//       let var1 = ee.Algorithms.If(
//         ee.String(ee.Feature(district).get('ADM1_NAME')).equals('Balochistan'),
//         ee.Number(1),
//         ee.Number(0)
//       )

//       let var2 = ee.Algorithms.If(
//         ee
//           .String(ee.Feature(district).get('ADM2_NAME'))
//           .equals('Nasirabad District'),
//         ee.Number(0),
//         ee.Number(1)
//       )

//       let var3 = ee.Number(var1).and(ee.Number(var2))

//       let customConnectedPixelCount = ee.Algorithms.If(
//         var3,
//         ee.Number(15),
//         ee.Number(100)
//       )
//       let connectedPixelsThreshold = ee.Algorithms.If(
//         var3,
//         ee.Number(8),
//         ee.Number(50)
//       )
//       const connections = floodedRoads.connectedPixelCount(
//         ee.Number(customConnectedPixelCount)
//       )
//       floodedRoads = floodedRoads.updateMask(
//         connections.gt(ee.Number(connectedPixelsThreshold))
//       )

//       let scale = ee.Algorithms.If(
//         ee.String(ee.Feature(district).get('ADM1_NAME')).equals('Balochistan'),
//         ee.Number(100),
//         ee.Number(80)
//       )

//       const floodedRoadVectors = floodedRoads.reduceToVectors({
//         geometry: ee.Feature(district).geometry(),
//         scale: 120,
//         eightConnected: true,
//         maxPixels: 1e10,
//         tileScale: 1,
//       })

//       const floodedRoadArray = floodedRoadVectors.toList(1e5)

//       const getCenters = function (feature) {
//         return ee
//           .Feature(feature)
//           .centroid({ maxError: 1 })
//           .geometry()
//           .coordinates()
//       }

//       const floodedRoadsCentroids = floodedRoadArray.map(getCenters)

//       const someObj = {
//         name: ee.Feature(district).get('ADM2_NAME'),
//         geometry: ee.Feature(district).geometry(),
//       }

//       return someObj

//       // resolve({
//       //   district: ee.Feature(district).get('ADM2_NAME'),
//       //   // geometry: ee.Feature(district).geometry(),
//       //   // results: {
//       //   //   total: districtArea,
//       //   //   before: beforeFloodAreaResult,
//       //   //   after: afterFloodAreaResult,
//       //   //   roads: floodedRoadsCentroids,
//       //   // },
//       // })
//     })
//   }

//   var exitCounter = 1

//   districts.evaluate(async (districtsCollection) => {
//     // MAYBE SEND A CALL TO THE DB TO CHECK IF LENTH IS EQUAL TO districtsCollection.features.length THEN SEND res.send
//     // res.send(districtsCollection.features.length.toString())
//     var index = 0
//     for (const something of districtsCollection.features) {
//       districtsArray = districts.toList(1, parseInt(index))

//       districtsFloodData = await districtsArray.map(
//         districtLandcoverGeneralFunction
//       )

//       districtsFloodData.evaluate((something) => {
//         res.send(something)
//       })

//       await districtsFloodData.evaluate(async (resultArray) => {
//         console.log(exitCounter)
//         if (!(exitCounter > districtsCollection.features.length - 1)) {
//           if (resultArray) {
//             await District.findOneAndUpdate(
//               {
//                 data_id: afterEnd,
//               },
//               {
//                 $push: {
//                   districts: resultArray[0] || null,
//                 },
//               }
//             )
//           } else {
//             await District.findOneAndUpdate(
//               {
//                 data_id: afterEnd,
//               },
//               {
//                 $push: {
//                   districts: null,
//                 },
//               }
//             )
//           }
//           exitCounter++
//         } else {
//           // res.send('Completed')
//           if (resultArray) {
//             await District.findOneAndUpdate(
//               {
//                 data_id: afterEnd,
//               },
//               {
//                 $push: {
//                   districts: resultArray[0] || null,
//                 },
//               }
//             )
//           } else {
//             await District.findOneAndUpdate(
//               {
//                 data_id: afterEnd,
//               },
//               {
//                 $push: {
//                   districts: null,
//                 },
//               }
//             )
//           }
//           res.send('Completed')
//         }
//       })
//       index++
//     }

//     // for (var index = 0; index < districtsCollection.features.length; index++) {
//     //   districtsArray = districts.toList(1, parseInt(index))

//     //   districtsFloodData = districtsArray.map(districtLandcoverGeneralFunction)

//     //   const databaseArray = await District.findOne()
//     //   console.log(databaseArray.districts.length)

//     //   await districtsFloodData.evaluate(async (resultArray) => {
//     //     if (!(exitCounter > districtsCollection.features.length - 1)) {
//     //       // console.log(exitCounter)
//     //       if (resultArray) {
//     //         await District.findOneAndUpdate(
//     //           {
//     //             data_id: afterEnd,
//     //           },
//     //           {
//     //             $push: {
//     //               districts: resultArray[0] || null,
//     //             },
//     //           }
//     //         )
//     //       } else {
//     //         await District.findOneAndUpdate(
//     //           {
//     //             data_id: afterEnd,
//     //           },
//     //           {
//     //             $push: {
//     //               districts: null,
//     //             },
//     //           }
//     //         )
//     //       }
//     //       exitCounter++
//     //     } else {
//     //       // res.send('Completed')
//     //       if (resultArray) {
//     //         await District.findOneAndUpdate(
//     //           {
//     //             data_id: afterEnd,
//     //           },
//     //           {
//     //             $push: {
//     //               districts: resultArray[0] || null,
//     //             },
//     //           }
//     //         )
//     //       } else {
//     //         await District.findOneAndUpdate(
//     //           {
//     //             data_id: afterEnd,
//     //           },
//     //           {
//     //             $push: {
//     //               districts: null,
//     //             },
//     //           }
//     //         )
//     //       }
//     //       // res.send('Completed')
//     //     }
//     //   })
//     // }
//   })
// }

const getEEdata = async (req, res) => {
  const results = await FloodData.find()

  console.log(results)

  let floodWater = []

  // results[0].districts.forEach((entry) => {
  //   floodWater.push(entry.RESULTS.AFTER['flood-water'])
  // })

  res.send(results)

  // res.status(200).json(
  //   floodWater
  //     .sort((x, y) => {
  //       return x - y
  //     })
  //     .reverse()
  // )
}

//GENERAL FUNCTION TO CALCULATE FLOOD PIXELS FOR A GIVEN REGION WITHIN A GIVEN TIME FRAME
const getFloodPixels = (geometry, dateBS, dateBE, dateAS, dateAE, satData) => {
  const filteredSatData = satData
    .filter(ee.Filter.eq('instrumentMode', 'IW'))
    .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
    .filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'))
    .filter(ee.Filter.eq('resolution_meters', 10))
    .filter(ee.Filter.bounds(geometry))
    .select(['VH'])

  const beforeFloodCollection = filteredSatData.filter(
    ee.Filter.date(dateBS, dateBE)
  )
  const afterFloodCollection = filteredSatData.filter(
    ee.Filter.date(dateAS, dateAE)
  )

  const beforeImage = beforeFloodCollection.mosaic().clip(geometry)
  const afterImage = afterFloodCollection.mosaic().clip(geometry)

  const beforeImageSmooth = toDB(RefinedLee(toNatural(beforeImage)))
  const afterImageSmooth = toDB(RefinedLee(toNatural(afterImage)))

  const differencePixels = afterImageSmooth.divide(beforeImageSmooth)
  const diffThreshold = 1.2
  const floodedPixels = differencePixels
    .gt(diffThreshold)
    .rename('FloodWater')
    .selfMask()

  return floodedPixels
}

// Function to convert image from dB to natural
const toNatural = (img) => {
  return ee.Image(10.0).pow(img.select(0).divide(10.0))
}

// Function to convert image from natural to dB
const toDB = (img) => {
  return ee.Image(img).log10().multiply(10.0)
}

//Apllying a Refined Lee Speckle filter as coded in the SNAP 3.0 S1TBX:
//https://github.com/senbox-org/s1tbx/blob/master/s1tbx-op-sar-processing/src/main/java/org/esa/s1tbx/sar/gpf/filtering/SpeckleFilters/RefinedLee.java
//Adapted by Guido Lemoine
const RefinedLee = (img) => {
  // img must be in natural units, i.e. not in dB!
  // Set up 3x3 kernels
  var weights3 = ee.List.repeat(ee.List.repeat(1, 3), 3)
  var kernel3 = ee.Kernel.fixed(3, 3, weights3, 1, 1, false)

  var mean3 = img.reduceNeighborhood(ee.Reducer.mean(), kernel3)
  var variance3 = img.reduceNeighborhood(ee.Reducer.variance(), kernel3)

  // Use a sample of the 3x3 windows inside a 7x7 windows to determine gradients and directions
  var sample_weights = ee.List([
    [0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0],
    [0, 1, 0, 1, 0, 1, 0],
    [0, 0, 0, 0, 0, 0, 0],
  ])

  var sample_kernel = ee.Kernel.fixed(7, 7, sample_weights, 3, 3, false)

  // Calculate mean and variance for the sampled windows and store as 9 bands
  var sample_mean = mean3.neighborhoodToBands(sample_kernel)
  var sample_var = variance3.neighborhoodToBands(sample_kernel)

  // Determine the 4 gradients for the sampled windows
  var gradients = sample_mean.select(1).subtract(sample_mean.select(7)).abs()
  gradients = gradients.addBands(
    sample_mean.select(6).subtract(sample_mean.select(2)).abs()
  )
  gradients = gradients.addBands(
    sample_mean.select(3).subtract(sample_mean.select(5)).abs()
  )
  gradients = gradients.addBands(
    sample_mean.select(0).subtract(sample_mean.select(8)).abs()
  )

  // And find the maximum gradient amongst gradient bands
  var max_gradient = gradients.reduce(ee.Reducer.max())

  // Create a mask for band pixels that are the maximum gradient
  var gradmask = gradients.eq(max_gradient)

  // duplicate gradmask bands: each gradient represents 2 directions
  gradmask = gradmask.addBands(gradmask)

  // Determine the 8 directions
  var directions = sample_mean
    .select(1)
    .subtract(sample_mean.select(4))
    .gt(sample_mean.select(4).subtract(sample_mean.select(7)))
    .multiply(1)
  directions = directions.addBands(
    sample_mean
      .select(6)
      .subtract(sample_mean.select(4))
      .gt(sample_mean.select(4).subtract(sample_mean.select(2)))
      .multiply(2)
  )
  directions = directions.addBands(
    sample_mean
      .select(3)
      .subtract(sample_mean.select(4))
      .gt(sample_mean.select(4).subtract(sample_mean.select(5)))
      .multiply(3)
  )
  directions = directions.addBands(
    sample_mean
      .select(0)
      .subtract(sample_mean.select(4))
      .gt(sample_mean.select(4).subtract(sample_mean.select(8)))
      .multiply(4)
  )
  // The next 4 are the not() of the previous 4
  directions = directions.addBands(directions.select(0).not().multiply(5))
  directions = directions.addBands(directions.select(1).not().multiply(6))
  directions = directions.addBands(directions.select(2).not().multiply(7))
  directions = directions.addBands(directions.select(3).not().multiply(8))

  // Mask all values that are not 1-8
  directions = directions.updateMask(gradmask)

  // "collapse" the stack into a singe band image (due to masking, each pixel has just one value (1-8) in it's directional band, and is otherwise masked)
  directions = directions.reduce(ee.Reducer.sum())

  //var pal = ['ffffff','ff0000','ffff00', '00ff00', '00ffff', '0000ff', 'ff00ff', '000000'];
  //Map.addLayer(directions.reduce(ee.Reducer.sum()), {min:1, max:8, palette: pal}, 'Directions', false);

  var sample_stats = sample_var.divide(sample_mean.multiply(sample_mean))

  // Calculate localNoiseVariance
  var sigmaV = sample_stats
    .toArray()
    .arraySort()
    .arraySlice(0, 0, 5)
    .arrayReduce(ee.Reducer.mean(), [0])

  // Set up the 7*7 kernels for directional statistics
  var rect_weights = ee.List.repeat(ee.List.repeat(0, 7), 3).cat(
    ee.List.repeat(ee.List.repeat(1, 7), 4)
  )

  var diag_weights = ee.List([
    [1, 0, 0, 0, 0, 0, 0],
    [1, 1, 0, 0, 0, 0, 0],
    [1, 1, 1, 0, 0, 0, 0],
    [1, 1, 1, 1, 0, 0, 0],
    [1, 1, 1, 1, 1, 0, 0],
    [1, 1, 1, 1, 1, 1, 0],
    [1, 1, 1, 1, 1, 1, 1],
  ])

  var rect_kernel = ee.Kernel.fixed(7, 7, rect_weights, 3, 3, false)
  var diag_kernel = ee.Kernel.fixed(7, 7, diag_weights, 3, 3, false)

  // Create stacks for mean and variance using the original kernels. Mask with relevant direction.
  var dir_mean = img
    .reduceNeighborhood(ee.Reducer.mean(), rect_kernel)
    .updateMask(directions.eq(1))
  var dir_var = img
    .reduceNeighborhood(ee.Reducer.variance(), rect_kernel)
    .updateMask(directions.eq(1))

  dir_mean = dir_mean.addBands(
    img
      .reduceNeighborhood(ee.Reducer.mean(), diag_kernel)
      .updateMask(directions.eq(2))
  )
  dir_var = dir_var.addBands(
    img
      .reduceNeighborhood(ee.Reducer.variance(), diag_kernel)
      .updateMask(directions.eq(2))
  )

  // and add the bands for rotated kernels
  for (var i = 1; i < 4; i++) {
    dir_mean = dir_mean.addBands(
      img
        .reduceNeighborhood(ee.Reducer.mean(), rect_kernel.rotate(i))
        .updateMask(directions.eq(2 * i + 1))
    )
    dir_var = dir_var.addBands(
      img
        .reduceNeighborhood(ee.Reducer.variance(), rect_kernel.rotate(i))
        .updateMask(directions.eq(2 * i + 1))
    )
    dir_mean = dir_mean.addBands(
      img
        .reduceNeighborhood(ee.Reducer.mean(), diag_kernel.rotate(i))
        .updateMask(directions.eq(2 * i + 2))
    )
    dir_var = dir_var.addBands(
      img
        .reduceNeighborhood(ee.Reducer.variance(), diag_kernel.rotate(i))
        .updateMask(directions.eq(2 * i + 2))
    )
  }

  // "collapse" the stack into a single band image (due to masking, each pixel has just one value in it's directional band, and is otherwise masked)
  dir_mean = dir_mean.reduce(ee.Reducer.sum())
  dir_var = dir_var.reduce(ee.Reducer.sum())

  // A finally generate the filtered value
  var varX = dir_var
    .subtract(dir_mean.multiply(dir_mean).multiply(sigmaV))
    .divide(sigmaV.add(1.0))

  var b = varX.divide(dir_var)

  var result = dir_mean.add(b.multiply(img.subtract(dir_mean)))
  return result.arrayFlatten([['sum']])
}

module.exports = {
  getDistrictData,
  getMapID,
  landClassificationDataGenerator,
  getEEdata,
  tempF,
  getDatafromMongo,
  getDistrictPolygons,
}
